// Generated by CoffeeScript 1.10.0
(function() {
  var Docker, Promise, createChainId, createChainIdFromParent, crypto, digest, es, fs, path, semver, sha256sum, tar;

  crypto = require('crypto');

  Promise = require('bluebird');

  Docker = require('dockerode');

  semver = require('semver');

  tar = require('tar-stream');

  es = require('event-stream');

  fs = Promise.promisifyAll(require('fs'));

  path = require('path');

  Promise.promisifyAll(Docker.prototype);

  Promise.promisifyAll(Docker({}).getImage().constructor.prototype);

  Promise.promisifyAll(Docker({}).getContainer().constructor.prototype);

  module.exports = Docker;

  sha256sum = function(data) {
    var hash;
    hash = crypto.createHash('sha256');
    hash.update(data);
    return hash.digest('hex');
  };

  digest = function(data) {
    return 'sha256:' + sha256sum(data);
  };

  createChainId = function(diffIds) {
    return createChainIdFromParent('', diffIds);
  };

  createChainIdFromParent = function(parent, dgsts) {
    var dgst;
    if (dgsts.length === 0) {
      return parent;
    }
    if (parent === '') {
      return createChainIdFromParent(dgsts[0], dgsts.slice(1));
    }
    dgst = digest(parent + ' ' + dgsts[0]);
    return createChainIdFromParent(dgst, dgsts.slice(1));
  };

  Docker.prototype.imageRootDir = function(image) {
    return Promise.all([this.infoAsync(), this.versionAsync().get('Version'), this.getImage(image).inspectAsync()]).spread(function(dockerInfo, dockerVersion, imageInfo) {
      var dkroot, imageId;
      dkroot = dockerInfo.DockerRootDir;
      imageId = imageInfo.Id;
      return Promise["try"](function() {
        var hash, hashType, ref;
        if (semver.lt(dockerVersion, '1.10.0')) {
          return imageId;
        }
        ref = imageId.split(':'), hashType = ref[0], hash = ref[1];
        return fs.readFileAsync(path.join(dkroot, "image/" + dockerInfo.Driver + "/imagedb/content", hashType, hash)).then(JSON.parse).then(function(metadata) {
          var cacheIdPath, layerId, ref1;
          layerId = createChainId(metadata.rootfs.diff_ids);
          ref1 = layerId.split(':'), hashType = ref1[0], hash = ref1[1];
          cacheIdPath = path.join(dkroot, "image/" + dockerInfo.Driver + "/layerdb", hashType, hash, 'cache-id');
          return fs.readFileAsync(cacheIdPath, {
            encoding: 'utf8'
          });
        });
      }).then(function(destId) {
        switch (dockerInfo.Driver) {
          case 'btrfs':
            return path.join(dkroot, 'btrfs/subvolumes', destId);
          case 'overlay':
            return imageInfo.GraphDriver.Data.RootDir;
          case 'vfs':
            return path.join(dkroot, 'vfs/dir', destId);
          default:
            throw new Error("Unsupported driver: " + dockerInfo.Driver + "/");
        }
      });
    });
  };

  Docker.prototype.createEmptyImage = function(imageConfig) {
    var layer, manifest;
    manifest = [
      {
        Config: 'config.json',
        RepoTags: null,
        Layers: ['0000/layer.tar']
      }
    ];
    layer = tar.pack();
    layer.entry({
      name: 'seed'
    }, String(Date.now() + Math.random()));
    layer.finalize();
    return Promise.fromCallback(function(callback) {
      return layer.pipe(es.wait(callback));
    }).then((function(_this) {
      return function(buf) {
        var config, image, imageId, layerConfig, now;
        now = (new Date()).toISOString();
        config = {
          config: imageConfig,
          created: now,
          rootfs: {
            type: 'layers',
            diff_ids: [digest(buf)]
          }
        };
        imageId = sha256sum(JSON.stringify(config));
        layerConfig = {
          id: imageId,
          created: now,
          config: imageConfig
        };
        image = tar.pack();
        image.entry({
          name: 'manifest.json'
        }, JSON.stringify(manifest));
        image.entry({
          name: 'config.json'
        }, JSON.stringify(config));
        image.entry({
          name: '0000/VERSION'
        }, '1.0');
        image.entry({
          name: '0000/json'
        }, JSON.stringify(layerConfig));
        image.entry({
          name: '0000/layer.tar'
        }, buf);
        image.finalize();
        return _this.loadImageAsync(image).then(function(stream) {
          return Promise.fromCallback(function(callback) {
            return stream.pipe(es.wait(callback));
          });
        })["return"](imageId);
      };
    })(this));
  };

}).call(this);
